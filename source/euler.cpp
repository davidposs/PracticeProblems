#include <iostream>
#include <math.h>
#include <cmath>
#include <random>
#include "euler.h"
#include <cassert>
#include <typeinfo>


/********************* Answers *********************/
const static int      problem001Answer = 233168;
const static int      problem002Answer = 4613732;
const static uint64_t problem003Answer = 6857;
const static int      problem004Answer = 906609;
const static int      problem005Answer = 232792560;
const static double   problem006Answer = 25164150;
const static uint64_t problem007Answer = 104743;
const static uint64_t problem008Answer = 23514624000;
/***************************************************/

/* ****************************************************************************
* Problem 1:
* Description: If we list all the natural numbers below 10 that are multiples 
               of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
			   Find the sum of all the multiples of 3 or 5 below 1000. 
* ****************************************************************************/
int problem1() {
	int sum = 0;
	for (int i = 0; i < 1000; i++) {
		if (i % 3 == 0 || i % 5 == 0) {
			sum += i;
		}
	}
	return sum;
}

/* ****************************************************************************
* Problem 2:
* Description: Each new term in the Fibonacci sequence is generated by adding 
*              the previous two terms. By starting with 1 and 2, the first 10 
*			   terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
*              By considering the terms in the Fibonacci sequence whose values
*			   do not exceed four million, find the sum of the even-valued terms.
* ****************************************************************************/
int problem2() {
	int f1 = 1;
	int f2 = 2;
	int temp = 0;
	int sum = 2;
	while (f2 < 4000000) {
		temp = f1;
		f1 = f2;
		f2 += temp;
		if (f2 % 2 == 0) {
			sum += f2;
		}
	}
	return sum;
}

/* ****************************************************************************
* Problem 3:   
* Description: The prime factors of 13195 are 5, 7, 13 and 29. What is the 
*              largest prime factor of the number 600851475143 ? 
* ****************************************************************************/
bool isPrime(uint64_t  num) {
	if (num <= 3) {
		return num > 1;
	}
	else if (num % 2 == 0 || num % 3 == 0) {
		return false;
	}
	else {
		for (int i = 5; i * i <= num; i += 6) {
			if (num % i == 0 || num % (i + 2) == 0) {
				return false;
			}
		}
	}
	return true;
}

uint64_t problem3() {
	uint64_t bigNumber = 600851475143;
	uint64_t  greatestPrimeFactor = 0;
	for (int i = 1; i < sqrt(bigNumber); i += 2) {
		if (bigNumber % i == 0 && isPrime(i)) {
			greatestPrimeFactor = i;
		}
	}
	return greatestPrimeFactor;
}

/* ****************************************************************************
* Problem 4:   Largest palindrome product
* Description: A palindromic number reads the same both ways. The largest 
*              palindrome made from the product of two 2-digit numbers is 
*      	       9009 = 91 × 99. Find the largest palindrome made from the 
*              product of two 3-digit numbers.
* ***************************************************************************/
int countDigits(unsigned long long num) {
	int digits = 0;
	do {
		num /= 10;
		digits++;
	} while (num);
	return digits;
}

bool isPalindrome(int num) {
	double base = 0;
	int temp = num;
	int numDigits = countDigits(num);
	int place = 0;
	if (num < 10 && num >= 0) {
		return true;
	}

	int* arr = new int[numDigits * sizeof(int)];

	/* Get each digit of the number and add to an array */
	for (int i = 0; i < numDigits; i++) {
		base = pow(10, numDigits - i - 1);
		place = temp / static_cast<int>(base);
		arr[i] = place;
		temp -= place * static_cast<int>(base);
	}

	/* Check if the array is a palindrome */
	for (int i = 0; i < numDigits / 2; i++) {
		if (arr[i] != arr[numDigits - i - 1]) {
			return false;
		}
	}
	delete arr;
	return true;
}

int problem4(int operandDigitCount) {
	int result = 0;
	int mul1 = 100;
	int mul2 = 100;
	int maxi = 0;
	int maxj = 0;
	double start = pow(10, operandDigitCount - 1);
	double end = pow(10, operandDigitCount);

	for (int i = static_cast<int>(start); i < end; i++) {
		for (int j = static_cast<int>(start); j < end; j++) {
			if (isPalindrome(i * j) && i * j > result) {
				result = j * i;
				maxi = i;
				maxj = j;
			}
		}
	}
	return result;
}

/* ****************************************************************************
* Problem 5
* Description: 2520 is the smallest number that can be divided by each of the 
*              numbers from 1 to 10 without any remainder. What is the smallest 
*              positive number that is evenly divisible by all of the numbers 
*              from 1 to 20?
* ***************************************************************************/
int problem5(int maxDivisor) {
	double semiPrimeProduct = pow(2, 4) * pow(3, 2) * 5 * 7 * 11 * 13 * 17 * 19;
	int product = 2520; // Start with our lower bound
	while (true) {
		if (product % static_cast<int>(semiPrimeProduct) == 0) {
			return product;
		}
		product += 2;
	}
	return product;
}

/* ****************************************************************************
* Problem 6:   
* Description: Find the difference between the sum of the squares of the first 
*              one hundred natural numbers and the square of the sum.
* ***************************************************************************/
double problem6(int max) {
	double sumOfSquares = 0;
	double squareOfSum = 0;
	for (int i = 0; i <= max; i++) {
		sumOfSquares += pow(i, 2);
		squareOfSum += i;
	}
	squareOfSum = pow(squareOfSum, 2);
	return squareOfSum - sumOfSquares;
}


/* ****************************************************************************
 * Problem 7:   10001st prime
 * Description: By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13,
 *              we can see that the 6th prime is 13. What is the 10001st prime
 *              number?
 * ***************************************************************************/
int64_t getRandomNumber(int64_t min, int64_t max) {
	std::random_device rd;
	std::mt19937_64 mt(rd());
	std::uniform_int_distribution<std::intmax_t> dist(min, max);
	return dist(mt);
}

uint64_t modExp(uint64_t base, uint64_t power, uint64_t mod) {
	uint64_t c = 1;
	base %= mod;
	while (power > 0) {
		if (power & 1) {
			c = (c * base) % mod;
		}
		power >>= 1;
		base = (base * base) % mod;
	}
	return c;
}

bool millerRabin(const uint64_t n, const int k) {
	uint64_t d = n - 1;
	uint64_t s = 0;
	uint64_t a;
	uint64_t x;
	uint64_t r;
	
	/* Factor out powers of 2 from d */
	while ((d & 1) == 0) {
		s++;
		d >>=1;
	}
	for (int i = 0; i < k; i++) {
		a = getRandomNumber(2, n - 1);
		x = modExp(a, d, n);
		if (x == 1 || x == n - 1) { 
			continue;
		}		
		for (r = 0; r < s; r++) {
			x = modExp(x, 2, n);
			if (x == 1) return false;
			if (x == n - 1) break;
		}
		if (r == s) {
			return false;
		}
	}
	return true;
}

bool checkPrime(uint64_t number) {
	/* Basic checks */
	if (number == 1)     { return false; }
	if (number <= 3)     { return true;  }
	if (number == 5)     { return true;  }
	if (number % 2 == 0) { return false; }
	if (number % 3 == 0) { return false; }
	if (number % 5 == 0) { return false; }
	if (millerRabin(number, 40)) {
		for (int i = 3; i < sqrt(number); i += 2) {
			if (number % i == 0) {
				return false;
			}
		}
		return true;
	}
	return false;
}

uint64_t problem7(int nthPrime) {
	int      foundPrimes = 0;
	uint64_t i           = 2;
	while (foundPrimes != nthPrime) {
		if (checkPrime(i)) {
			foundPrimes++;
		}
		i++;
	}
	return i - 1;
}

/* ****************************************************************************
* Problem 8:   Largest product in a series
* Description: The four adjacent digits in the 1000-digit number that have the 
*              greatest product are 9 × 9 × 8 × 9 = 5832
*			   73167176531330624919225119674426574742355349194934
*			   96983520312774506326239578318016984801869478851843
*			   85861560789112949495459501737958331952853208805511
*			   12540698747158523863050715693290963295227443043557
*			   66896648950445244523161731856403098711121722383113
*			   62229893423380308135336276614282806444486645238749
*			   30358907296290491560440772390713810515859307960866
*			   70172427121883998797908792274921901699720888093776
*			   65727333001053367881220235421809751254540594752243
*			   52584907711670556013604839586446706324415722155397
*			   53697817977846174064955149290862569321978468622482
*			   83972241375657056057490261407972968652414535100474
*			   82166370484403199890008895243450658541227588666881
*			   16427171479924442928230863465674813919123162824586
*			   17866458359124566529476545682848912883142607690042
*			   24219022671055626321111109370544217506941658960408
*			   07198403850962455444362981230987879927244284909188
*			   84580156166097919133875499200524063689912560717606
*			   05886116467109405077541002256983155200055935729725
*			   71636269561882670428252483600823257530420752963450
*              Find the thirteen adjacent digits in the 1000-digit number that
*			   have the greatest product. What is the value of this product?
* ****************************************************************************/


uint64_t problem8(int numDigits) {
	std::string series =
		"73167176531330624919225119674426574742355349194934"
		"96983520312774506326239578318016984801869478851843"
		"85861560789112949495459501737958331952853208805511"
		"12540698747158523863050715693290963295227443043557"
		"66896648950445244523161731856403098711121722383113"
		"62229893423380308135336276614282806444486645238749"
		"30358907296290491560440772390713810515859307960866"
		"70172427121883998797908792274921901699720888093776"
		"65727333001053367881220235421809751254540594752243"
		"52584907711670556013604839586446706324415722155397"
		"53697817977846174064955149290862569321978468622482"
		"83972241375657056057490261407972968652414535100474"
		"82166370484403199890008895243450658541227588666881"
		"16427171479924442928230863465674813919123162824586"
		"17866458359124566529476545682848912883142607690042"
		"24219022671055626321111109370544217506941658960408"
		"07198403850962455444362981230987879927244284909188"
		"84580156166097919133875499200524063689912560717606"
		"05886116467109405077541002256983155200055935729725"
		"71636269561882670428252483600823257530420752963450";
	uint64_t product = 1;
	uint64_t max     = 1;
	bool     skip    = false;
	int* currSequence = new int[numDigits];
	std::fill_n(currSequence, numDigits, 0);
	unsigned int currIndex = 0;
	int currDigit = 0;
	/* Loop through series, creating a new sequence 13 digits at a time */
	while (currIndex <= series.length() - numDigits) {
		product = 1;
		skip    = false;
		for (int i = 0; i < numDigits; i++) {
			currDigit = series[currIndex + i] - '0';
			//* The product of this subseries is 0, skip to next index */
			if (currDigit == 0) {
				currIndex += i + 1;
				skip = true;
				break;
			}
			currSequence[i] = series[currIndex + i] - '0';
		}
		if (!skip) {
			for (int i = 0; i < numDigits; i++) {
				product *= currSequence[i];
			}
			if (product > max) {
				max = product;
			}
			currIndex++;
		}
	} 
	delete[] currSequence;
	return max;
}

/* ****************************************************************************
* Problem 9:   Special Pythagorean Triplet
* Description: A Pythagorean triplet is a set of three natural numbers where:
               a < b < c, and a^2 + b^2 = c^2. There exists exactly one 
			   Pythagorean triplet for which a + b + c = 1000. Find the product
			   a * b * c
* ****************************************************************************/
//i didnt do this because i didn't want to do any more


void printEulerProblems() {
	std::cout << "Calculating Euler Problems..." << std::endl;
	validateAnswer("Problem 1", problem1(),      problem001Answer);
	validateAnswer("Problem 2", problem2(),      problem002Answer);
	validateAnswer("Problem 3", problem3(),      problem003Answer);
	validateAnswer("Problem 4", problem4(3),     problem004Answer);
	validateAnswer("Problem 5", problem5(20),    problem005Answer);
	validateAnswer("Problem 6", problem6(100),   problem006Answer);
	validateAnswer("Problem 7", problem7(10001), problem007Answer);
	validateAnswer("Problem 8", problem8(13),    problem008Answer);
}


template <typename T>
void validateAnswer(std::string problem, T answer, T expected) {
	if (answer == expected) {
		std::cout << problem << " is correct! Answer: " << answer << std::endl;
	}
	else {
		std::cout << problem << " is wrong! Expected " << expected << " but calculated " << answer;
	}
}
